
diff --git a/home/sabbat/sabbat-tools/sabbat_tools/loganalyce.py b/home/sabbat/sabbat-tools/sabbat_tools/loganalyce.py
--- a/home/sabbat/sabbat-tools/sabbat_tools/loganalyce.py
+++ b/home/sabbat/sabbat-tools/sabbat_tools/loganalyce.py
@@ -5,7 +5,10 @@
 import argparse
 import sys
 import json
-import gzip
+import gzip
+import bz2
+import lzma
+
 import ipaddress
 import logging
 from collections import Counter, OrderedDict
@@ -17,6 +20,12 @@
 from concurrent.futures import ThreadPoolExecutor
 import signal
 import stat
+
+# zstandard es opcional
+try:
+    import zstandard as zstd  # pip install zstandard
+    HAVE_ZSTD_LIB = True
+except Exception:
+    HAVE_ZSTD_LIB = False

 # =========================
 #  Config & Internationalization
@@ -76,6 +85,8 @@
         "arg_hardened_regex": "Use hardened regex engine if available ('regex' module) to reduce ReDoS risk",
         "arg_large_threshold": "Warn early if line count >= N before analysis (0 to disable)",
         "perm_denied": "Permission denied: cannot read '{file}'. Try 'sudo' or adjust permissions.",
+        "unsupported_codec": "Unsupported compressed format for file '{file}'.",
+        "zstd_missing": "The file '{file}' appears to be Zstandard (.zst) but 'zstandard' module is not installed.",
         "is_dir": "Error: '{file}' is a directory, not a regular file.",
     },
     "es": {
@@ -130,6 +141,8 @@
         "arg_hardened_regex": "Usar motor regex endurecido si está disponible (módulo 'regex') para reducir ReDoS",
         "arg_large_threshold": "Avisar antes si el nº de líneas >= N (0 para desactivar)",
         "perm_denied": "Permiso denegado: no puedo leer '{file}'. Prueba con 'sudo' o ajusta los permisos.",
+        "unsupported_codec": "Formato de compresión no soportado para el fichero '{file}'.",
+        "zstd_missing": "El fichero '{file}' parece Zstandard (.zst) pero falta el módulo 'zstandard'.",
         "is_dir": "Error: '{file}' es un directorio, no un fichero.",
     },
 }
@@ -185,6 +198,56 @@
     return iv

 # ---------- File pre-checks (existence / regular / readable) ----------
 from pathlib import Path

 def _stderr(msg: str) -> None:
     print(msg, file=sys.stderr)
@@ -212,14 +275,32 @@ def ensure_readable_file(path_str: str) -> tuple[bool, str | None, int]:
     if not is_regular:
         return False, T.get("is_dir", T["bad_file"]).format(file=path_str), 2

-    # 3) Intento de apertura no destructiva para confirmar legibilidad
+    # 3) Intento de apertura no destructiva para confirmar legibilidad (por magic bytes)
     try:
-        if p.suffix == ".gz":
-            with gzip.open(p, "rt", errors="ignore") as fh:
-                fh.read(0)
-        else:
-            with open(p, "rb") as fh:
-                fh.read(0)
+        with open(p, "rb") as fh:
+            header = fh.read(8)
+        # Firmas: gzip 1F 8B; bzip2 "BZh"; xz FD 37 7A 58 5A 00; zstd 28 B5 2F FD
+        if header.startswith(b"\x1f\x8b"):
+            with gzip.open(p, "rt", errors="ignore") as fh:
+                fh.read(0)
+        elif header.startswith(b"BZh"):
+            with bz2.open(p, "rt", errors="ignore") as fh:
+                fh.read(0)
+        elif header.startswith(b"\xFD7zXZ\x00"):
+            with lzma.open(p, "rt", errors="ignore", format=lzma.FORMAT_XZ) as fh:
+                fh.read(0)
+        elif header.startswith(b"\x28\xB5\x2F\xFD"):
+            if not HAVE_ZSTD_LIB:
+                return False, T["zstd_missing"].format(file=path_str), 2
+            # Apertura ligera Zstd (comprobación)
+            dctx = zstd.ZstdDecompressor()
+            with open(p, "rb") as fh:
+                with dctx.stream_reader(fh) as r:
+                    r.read(0)
+        else:
+            # Texto plano u otros: lectura binaria mínima
+            with open(p, "rb") as fh:
+                fh.read(0)
     except PermissionError:
         return False, T["perm_denied"].format(file=path_str), 2
     except IsADirectoryError:
         return False, T.get("is_dir", T["bad_file"]).format(file=path_str), 2
     except OSError as e:
         return False, T["analysis_error"].format(err=e), 2
     return True, None, 0

+# ---------- Magic-bytes based opener ----------
+def _open_by_magic(path: str, encoding: str, errors: str = "surrogateescape"):
+    """Devuelve un objeto de lectura texto según magic bytes (gz/bz2/xz/zst/plano)."""
+    if path == "-":
+        return sys.stdin
+    with open(path, "rb") as f:
+        header = f.read(8)
+    if header.startswith(b"\x1f\x8b"):  # gzip
+        return gzip.open(path, "rt", encoding=encoding, errors=errors, newline="")
+    if header.startswith(b"BZh"):  # bzip2
+        return bz2.open(path, "rt", encoding=encoding, errors=errors, newline="")
+    if header.startswith(b"\xFD7zXZ\x00"):  # xz
+        return lzma.open(path, "rt", encoding=encoding, errors=errors, format=lzma.FORMAT_XZ, newline="")
+    if header.startswith(b"\x28\xB5\x2F\xFD"):  # zstd
+        if not HAVE_ZSTD_LIB:
+            raise OSError(T["zstd_missing"].format(file=path))
+        dctx = zstd.ZstdDecompressor()
+        fh = open(path, "rb")
+        # devolvemos un file-like envuelto en texto
+        reader = dctx.stream_reader(fh)
+        import io
+        return io.TextIOWrapper(reader, encoding=encoding, errors=errors, newline="")
+    # por defecto: texto plano
+    return open(path, "rt", encoding=encoding, errors=errors, newline="")
+
 # =========================
 #  Hardened regex builders (ReDoS mitigation)
 # =========================
@@ -315,11 +396,8 @@ class LogAnalyzer:
         return None

     def _open_stream(self):
-        if self.log_file == "-":
-            if self.deny_stdin:
-                raise PermissionError("stdin disabled by --deny-stdin")
-            return sys.stdin
-        if self.log_file.endswith(".gz"):
-            return gzip.open(self.log_file, "rt", encoding=self._resolve_encoding(), errors="surrogateescape", newline="")
-        return open(self.log_file, "r", encoding=self._resolve_encoding(), errors="surrogateescape", newline="")
+        if self.log_file == "-" and self.deny_stdin:
+            raise PermissionError("stdin disabled by --deny-stdin")
+        # Usa detection por magic bytes para soportar gz/bz2/xz/zst/texto
+        return _open_by_magic(self.log_file, encoding=self._resolve_encoding(), errors="surrogateescape")

     def _resolve_encoding(self):
         if self.encoding and self.encoding.lower() != "auto":

